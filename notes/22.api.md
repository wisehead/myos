#一、汇编APP调用API
##1.1.显示字符串API


```cpp
void cons_putstr0(struct CONSOLE *cons, char *s)
{
    for (; *s != 0; s++) {
        cons_putchar(cons, *s, 1);
    }
    return;
}

void cons_putstr1(struct CONSOLE *cons, char *s, int l)
{
    int i;
    for (i = 0; i < l; i++) {
        cons_putchar(cons, s[i], 1);
    }
    return;
}
```

##1.2.注册中断号
我们借鉴BIOS的调用方式，在寄存器中存入功能号，使得只用1个INT就可以选择调用不同的函数。
在BIOS中，用来存放功能号的寄存器一般是AH，最多只能设置256个API函数。
我们使用EDX来存放功能号，就可以设置多达42亿个功能函数。

> 功能号1：显示单个字符（AL = 字符编码）
> 功能号2：显示字符串0（EBX = 字符串地址）
> 功能号3：显示字符串1（EBX = 字符串地址，ECX = 字符串长度）


##1.3._asm_hrb_api汇编
```
_asm_hrb_api:
        STI
        PUSHAD      ; 用于保存寄存器值的PUSH
        PUSHAD      ; 用于向hrb_api传值的PUSH
        CALL        _hrb_api
        ADD         ESP,32
        POPAD
        IRETD
```

##1.4.hrb_api函数C语言
需要指定CS = 0xfe8

```cpp
int *hrb_api(int edi, int esi, int ebp, int esp, int ebx, int edx, int ecx, int eax)
{
    int cs_base = *((int *) 0xfe8);
    struct TASK *task = task_now();
    struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);
    if (edx == 1) {
        cons_putchar(cons, eax & 0xff, 1);
    } else if (edx == 2) {
        cons_putstr0(cons, (char *) ebx + cs_base);
    } else if (edx == 3) {
        cons_putstr1(cons, (char *) ebx + cs_base, ecx);
    } else if (edx == 4) {
        return &(task->tss.esp0);
    }
    return 0;
}
```

cmd_app中指定CS = 0xfe8中保存的值。

```cpp
int cmd_app(struct CONSOLE *cons, int *fat, char *cmdline)
{
...
...
    if (finfo != 0) {
        /*找到文件的情况*/
        p = (char *) memman_alloc_4k(memman, finfo->size);
        q = (char *) memman_alloc_4k(memman, 64 * 1024);
        *((int *) 0xfe8) = (int) p;
        file_loadfile(finfo->clustno, finfo->size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));
        set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60);
        set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW + 0x60);
        if (finfo->size >= 8 && strncmp(p + 4, "Hari", 4) == 0) {
            p[0] = 0xe8;
            p[1] = 0x16;
            p[2] = 0x00;
            p[3] = 0x00;
            p[4] = 0x00;
            p[5] = 0xcb;
        }
        start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &(task->tss.esp0));
        memman_free_4k(memman, (int) p, finfo->size);
        memman_free_4k(memman, (int) q, 64 * 1024);
        cons_newline(cons);
        return 1;
    }
    /*没有找到文件的情况*/
    return 0;
}
```

##1.5.修改IDT
```cpp
void init_gdtidt(void)
{
...
...

    /* IDT设置*/
    set_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32);
    set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32);
    set_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32);
    set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32);
    set_gatedesc(idt + 0x40, (int) asm_hrb_api, 2 * 8, AR_INTGATE32);//here

    return;
}
```

#二、C语言APP调用API
##2.1 a.c

```cpp
void api_putchar(int c);
void api_end(void);

void HariMain(void)
{
    api_putchar('A');
    api_end();
}
```

##2.2 asm API

```
[FORMAT "WCOFF"]            ; 生成对象文件的模式
[INSTRSET "i486p"]      ; 表示使用486兼容指令集
[BITS 32]                           ; 生成32位模式机器语言
[FILE "a_nask.nas"]     ; 源文件名信息

        GLOBAL  _api_putchar
        GLOBAL  _api_end

[SECTION .text]

_api_putchar:   ; void api_putchar(int c);
        MOV     EDX,1
        MOV     AL,[ESP+4]      ; c
        INT     0x40
        RET
_api_end: ; void api_end(void);
        MOV         EDX,4
        INT         0x40
```

##2.3 Makefile

```
a.bim : a.obj a_nask.obj Makefile
    $(OBJ2BIM) @$(RULEFILE) out:a.bim map:a.map a.obj a_nask.obj

a.hrb : a.bim Makefile
    $(BIM2HRB) a.bim a.hrb 0
```

##2.4 hard code
将开头的6个字节替换成 “EB 16 00 00 00 CB”
这6个字节相当于

```
[BITS 32]
	CALL 0x1b
	RETF
```