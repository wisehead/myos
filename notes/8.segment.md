#1.GDT，分段

分段使用段寄存器。16位的时候，如果计算地址，只要将地址乘以16就可以了。
但现在是32位，如果写成“MOV AL,[DS:EBX]”，地址计算是DS+EBX，不再需要DS乘以16. 如果省略DS的地址，也会认为指定了DS，为0.

* 按照这种分段方法，为了表示一个段，需要以下信息。
--段的大小
--段的起始地址
--段的管理属性（禁止写入，禁止执行，系统专用等）
CPU用8个字节（64bit）来表示这些信息。但是用于指定段的寄存器只有16位。
段号可以用0~8191的数。因为段寄存器是16位，本来可以处理0~65535范围的数，但由于CPU设计上的原因，段寄存器的低三位不能使用。因此能够使用的部分只有13位，能够处理的就只有位于0~8191的段了。

所以管理这么多段的元数据就需要 8192*8 = 64KB。
CPU没那么大存储能力，不可能存储这么多数据，需要写入内存。这64KB的数据就成为GDT。

* GDT 是 global segment descriptor table的缩写，意思是全局段号记录表。将这些数据整齐地排列在内存的某个地方，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。

--段起始地址：32位表示，low（2byte），mid（1byte），high（1byte）
--段上限：只能使用20位，原则上段上限最大指定1MB。所以这里有一个trick，在段的属性里设置了一个标志位，叫做Gbit。这个标志位是1的时候，limit的单位不解释成字节byte，而是解释成页page。
    这样一来，4K * 1MB = 4GB，所以可以指定4G的段。 limit_low(2byte), limit_high(0.5byte = 4bit)
--段属性：12bit，高4位放在limit_high的高4位里，ar有16bit。
    --高4位：扩展访问权。这四位在286时代没有，386才开始。这四位是由“GD00”构成，G是指刚才所说的Gbit，D是指段的模式，1是指32位模式，0是指16位模式。
    --低8位：
        --00000000（0x00）：未使用的记录表
        --10010010（0x92）：系统专用，可读写的段。不可执行。
        --10011010（0x9a）：系统专用，可执行的段。可读不可写。
        --11110010（0xf2）：应用程序用，可读写的段，不可执行。
        --11111010（0xfa）：应用程序用，可执行的段，可读不可写。
        CPU到底处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权为0x9a的段，还是0xfa的段。
        
        
#2.段和GDT的关系
所有的段，都在GDT注册
每个段的大小不一定是64KB

#3 asmhead.nas中的临时GDT
```
        ALIGNB  16
GDT0:
        RESB    8               ; 初始值
        DW      0xffff,0x0000,0x9200,0x00cf ; 可以读写的段（segment）32bit
        DW      0xffff,0x0000,0x9a28,0x0047 ; 可执行的文件的32bit寄存器（bootpack用）

        DW      0
GDTR0:
        DW      8*3-1
        DD      GDT0

        ALIGNB  16
bootpack:
```

*  GDT0 也是一种特定的GDT。0号是空区域（null sector），不能够在哪里定义段。1号和2号分别由下式指定。我们用纸笔事先计算了一下，然后用DW排列出来，所以是写死的，临时的。

```cpp
set_segmdesc(gdt+1, 0xffffffff, 0x00000000, AR_DATA32_RW);
set_segmdesc(gdt+2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);
```
