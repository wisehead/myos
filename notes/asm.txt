1.各种寄存器
AX--accumulator, 累加寄存器
CS--counter，计数寄存器
DX--data，数据寄存器
BX--base，基址寄存器
SP--stack pointer，栈指针寄存器
BP——base pointer，基址指针寄存器
SI--source index，源变址寄存器
DI——destination index，目的变址寄存器


ES——附加段寄存器(extra segment)
CS——代码段寄存器(code segment)
SS——栈段寄存器(stack segment)
DS——数据段寄存器(data segment)
FS——没有名称（segment part 2）
GS——没有名称（segment part 3）

CR0——特殊的32位寄存器，也就是control register 0，是一个非常重要的寄存器，只有操作系统才能使用。
EFLAGS——存储CPU运算的一些标志位
GDT0——保存GDT的地址。
IMR: interrupt mask register, 中断屏蔽寄存器
ICW: initial control word. 初始化控制数据

2.寄存器限制
只有BX、BP、SI、DI几个寄存器，可以用寄存器指定内存地址，剩下的AX、CX、DX、SP不可以。
C语言和汇编联合使用的时候，EAX, ECX, EDX这几个寄存器可以随便使用，其它寄存器只能读，不能写。因为其它寄存器在编译C语言时，用来存重要的值。

3.操作系统对内存的使用
0x00000000 ~ 0x000fffff: 虽然在启动中会多次使用，但之后就变空。（1MB）
--------------------------------------------
--0地址：BOIS程序用来实现各种功能的地方。
--0x00000ff0: BOOTINFO
--0x00007c00~~0x00007dff:启动区内容的装载地址。(IPL)
--0x00008000:磁盘内容拷贝到内存的地址。
--0x0000c200:操作系统地址(OS)
--0x000a0000~~0x000affff:VRAM显卡内存地址
--0x000f0000地址：存放这BIOS程序本身
--------------------------------------------
--0x00100000 ~ 0x00267fff: 用于保存软盘的内容（1440KB）
--0x00268000 ~ 0x0026f7ff: 空（30KB）
--0x0026f800 ~ 0x0026ffff: IDT（2KB）
--0x00270000 ~ 0x0027ffff: GDT（64KB）
--0x00280000 ~ 0x002fffff: bootpack.hrb（512KB）
--0x00300000 ~ 0x003fffff: 栈及其它（1MB）
--0x00400000 ~ NIL       ：空


4.BIOS中断和DOS中断的区别
bios是主板预装好的input、output系统，而dos是需要安装才能使用操作系统。用int条用中断以后可以通过不同的系统达到不同的目的和效果。其中int 1 -20 是bios中断，int21 专门用于dos中断。
只有16位汇编才能访问BIOS，32位汇编不能访问。

5.如果汇编和C语言联合使用的话，有的寄存器可以自由使用，有的寄存器不能自由使用，能自由使用的只有eax, ecx, edx,这三个。至于其它寄存器，智能使用其值，而不能改变其值。
因为这些寄存器在c语言编译后生成的机器语言中，用于记忆非常重要的值。

6.新指令
（1）INSTRSET指令
    [INSTRSET "i486p"]              ; 使用到486为止的指令，为了能够使用386以后的LGDT，EAX，CR0等关键字。
（2）LGDT，读取GDT
（3）ALIGNB 16，一直添加DB 0，直到地址被16整除。
（4）PUSHFD，POPFD；读写EFLAGS的指令
（5）ORG 0x1234；程序加载到0x1234，指定内存地址。
（6）IRETD；中断处理完成后，不能执行RET，必须执行IRETD。
（7）PUSHAD；相当于
    -PUSH EAX
    -PUSH EBX
    -PUSH ECX
    -PUSH EDX
    -PUSH ESP
    -PUSH EBP
    -PUSH ESI
    -PUSH EDI
（8）POPAD；相当于以上相反的顺序，把它们全部POP出来。
（9）STI；它是CLI的逆指令。执行STI后，IF（interrup flag）变为1，CPU接受来自外部设备的中断。


7.GDT，分段
分段使用段寄存器。16位的时候，如果计算地址，只要将地址乘以16就可以了。
但现在是32位，如果写成“MOV AL,[DS:EBX]”，地址计算是DS+EBX，不再需要DS乘以16. 如果省略DS的地址，也会认为指定了DS，为0.

按照这种分段方法，为了表示一个段，需要一下信息。
--段的大小
--段的起始地址
--段的管理属性（禁止写入，禁止执行，系统专用等）
CPU用8个字节（64bit）来表示这些信息。但是用于指定段的寄存器只有16位。
段号可以用0~8191的数。因为段寄存器是16位，本来可以处理0~65535范围的数，但由于CPU设计上的原因，段寄存器的低三位不能使用。因此能够使用的部分只有13位，能够处理的就只有位于0~8191的段了。

所以管理这么多段的元数据就需要 8192*8 = 64KB。
CPU没那么大存储能力，不可能存储这么多数据，需要写入内存。这64KB的数据就成为GDT。

GDT 是 global segment descriptor table的缩写，意思是全局段号记录表。将这些数据整齐地排列在内存的某个地方，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。

--段起始地址：32位表示，low（2byte），mid（1byte），high（1byte）
--段上限：只能使用20位，原则上段上限最大指定1MB。所以这里有一个trick，在段的属性里设置了一个标志位，叫做Gbit。这个标志位是1的时候，limit的单位不解释成字节byte，而是解释成页page。
    这样一来，4K * 1MB = 4GB，所以可以指定4G的段。 limit_low(2byte), limit_high(0.5byte = 4bit)
--段属性：12bit，高4位放在limit_high的高4位里，ar有16bit。
    --高4位：扩展访问权。这四位在286时代没有，386才开始。这四位是由“GD00”构成，G是指刚才所说的Gbit，D是指段的模式，1是指32位模式，0是指16位模式。
    --低8位：
        --00000000（0x00）：未使用的记录表
        --10010010（0x92）：系统专用，可读写的段。不可执行。
        --10011010（0x9a）：系统专用，可执行的段。可读不可写。
        --11110010（0xf2）：应用程序用，可读写的段，不可执行。
        --11111010（0xfa）：应用程序用，可执行的段，可读不可写。
        CPU到底处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权为0x9a的段，还是0xfa的段。

8.IDT
IDT是“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会临时切花过去处理这种突发事件。这就是中断功能。

IDT记录了0~255的中断号码和调用函数的对应关系。

9.PIC
PIC:programmable interrupt controller.) 可编程中断控制器。
IMR: interrupt mask register, 中断屏蔽寄存器（8位）
ICW: initial control word. 初始化控制数据（8位）

CPU只能处理一个中断，不够用，所以IBM在主板上增加了辅助芯片。现在他们已经被集成到一个芯片组里了。

PIC是将8个中断信号集合成一个中断信号的装置。PIC监视着输入管教的8个中断信号。只要有一个中断信号进来，就将唯一的输出管教信号变成ON，并通知给CPU。IBM想要通过增加PIC来处理更多的中断信号，因为电脑上会有8个以上的外部设备，所以就把中断信号设计成15个，并为此增设了两个PIC。

与CPU直接相连的PIC是主PIC，与主PIC相连的PIC是从PIC。主PIC负责处理0号到7号的中断信号，从PIC负责处理从8号到15号的中断信号。
另外，从PIC通过2号IRQ与主PIC相连。

void init_pic(void)
/* PIC初始化 */
{
    io_out8(PIC0_IMR,  0xff  ); /* 禁止所有中断 */
    io_out8(PIC1_IMR,  0xff  ); /* 禁止所有中断 */

    io_out8(PIC0_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC0_ICW2, 0x20  ); /* IRQ0-7由INT20-27接收 */
    io_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2相连 */
    io_out8(PIC0_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC1_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC1_ICW2, 0x28  ); /* IRQ8-15由INT28-2f接收 */
    io_out8(PIC1_ICW3, 2     ); /* PIC1由IRQ2连接 */
    io_out8(PIC1_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC0_IMR,  0xfb  ); /* 11111011 PIC1以外全部禁止 */
    io_out8(PIC1_IMR,  0xff  ); /* 11111111 禁止所有中断 */

    return;
}


IMR: interrupt mask register, 中断屏蔽寄存器。
8位分别对应8路IRQ信号。如果某一位的值是1，则该位所对应的IRQ信号被屏蔽，PIC就忽略该信号。

ICW: initial control word. 初始化控制数据
ICW有4个，分别编号为1~4，共有4个字节的数据。

INT0x20~0x2f接收中断信号IRQ0~15，INT 0x00~0x1f不能用。当应用程序想要干坏事的时候，CPU内部会自动产生INT0x00~0x1f，如果IRQ与这些号码重复了，CPU就分不清它到底是IRQ，还是CPU的系统保护通知。

鼠标是IRQ12，键盘是IRQ1
所以用int 0x2c 和int 0x21的中断处理程序来处理二者的中断。



10.切换32位保护模式
;   切换到保护模式

[INSTRSET "i486p"]              ; 说明使用486指令

        LGDT    [GDTR0]         ; 设置临时GDT
        MOV     EAX,CR0
        AND     EAX,0x7fffffff  ; 设bit31为0（禁用分页）
        OR      EAX,0x00000001  ; bit0到1转换（保护模式过渡）
        MOV     CR0,EAX
        JMP     pipelineflush
pipelineflush:
        MOV     AX,1*8          ;  可读写的段 32bit
        MOV     DS,AX
        MOV     ES,AX
        MOV     FS,AX
        MOV     GS,AX
        MOV     SS,AX

//LGDT,不管三七二十一，把随意准备的GDT给读进来。对于这个暂定的GDT，我们以后还要重新设置。
//然后将CR0这个特殊的32位寄存器的值带入EAX，并将最高位置为0，最低位置为1，再将这个值返回给CR0寄存器。这样就完成了模式转换，进入到不用颁的保护模式。
//保护模式与之前的16位模式不同，段寄存器的解释不是16倍，而是能够使用GDT。这里的“保护”，来自英文的“protect”。在这种模式下，应用程序既不能随便改变段的设定，又不能使用操作系统专用的段。操作系统收到CPU的保护，所以称为保护模式。在保护模式中，有带保护的16位模式，有带保护的32位模式两种。我们要使用的是带保护的32位模式。

//讲解CPU的书上会讲到，通过带入CR0而切换到保护模式时，要马上执行JMP指令。为什么呢？应为变成保护模式后，机器语言的解释要发生变化。CPU为了加快指令的执行速度而使用了管道（pipeline）的机制，就是说，前一条指令还在执行的时候，就开始解释下一条，甚至是再下一条指令。因为模式变了，需要重新解释一遍，所以加入了JMP指令。

//而且在进入保护模式后，段寄存器的意思也变了（不再是乘以16然后再加的意思），除了CS以外所有段寄存器的值都从0x0000编程了0x0008。CS保持原装是因为如果CS也变了，会造成混乱，所以只有CS要放到后面再处理。0x0008相当于“gdt+1”的段。





11. IN / OUT port
//PIC初始化相关
#define PIC0_ICW1       0x0020
#define PIC0_OCW2       0x0020
#define PIC0_IMR        0x0021
#define PIC0_ICW2       0x0021
#define PIC0_ICW3       0x0021
#define PIC0_ICW4       0x0021
#define PIC1_ICW1       0x00a0
#define PIC1_OCW2       0x00a0
#define PIC1_IMR        0x00a1
#define PIC1_ICW2       0x00a1
#define PIC1_ICW3       0x00a1
#define PIC1_ICW4       0x00a1

0x60 PORT_KEYDAT//键盘
0x64 PORT_KEYSTA//键盘控制电路
0x64 PORT_KEYCMD//键盘

0x03c7//读调色板号
0x03c8//写调色板号
0x03c9//调色板RGB数据
//将想要设定的调色板号码写入0x03c8,紧接着，按R,G,B的顺序写入0x03c9。
//如果想要读出当前调色板的状态，首先要将调色板的好吗写入0x03c7，再从0x03c9读取三次。

12. IN / OUT comand
0x02 —— KEYSTA_SEND_NOTREADY//if (io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY == 0)
0x47 —— KBC_MODE
0x60 —— KEYCMD_WRITE_MODE

void wait_KBC_sendready(void) {
    /* 等待键盘控制电路准备完毕 */
    for (;;) {
        if ((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0) {
            break;
        }
    }
    return;
}

//让键盘控制电路做好准备工作，等待控制指令的到来。如果键盘电路可以接受CPU指令了，CPU从设备号码0x0064处所读取的数据的倒数第二位应该是0.在确认到这一位是0之前，程序一直通过for语句循环查询。

void init_keyboard(void) {
    /* 初始化键盘控制电路 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, KBC_MODE);
    return;
}

//一边确认可否往键盘控制电路发送信息，一步安发送模式指定指令，指令中包含着设定为何种模式。模式设定的指令是0x60，利用鼠标模式的模式号码是0x47.

#define KEYCMD_SENDTO_MOUSE   0xd4
#define MOUSECMD_ENABLE     0xf4
void enable_mouse(struct MOUSE_DEC *mdec) {
    /* 鼠标有效 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);
    /* 顺利的话，ACK(0xfa)会被送过来 */
    mdec->phase = 0; /* 等待0xfa的阶段 */
    return;
}

//如果往键盘控制电路发送0xd4指令，下一个数据就会自动发给鼠标。我们根据这一特性来发送激活鼠标的指令。
//另一方面，鼠标收到激活指令以后，马上就给CPU发送答复信息，这个答复信息就是oxfa。


0xd1 —— KEYCMD_WRITE_OUTPORT  //
0xdf —— KBC_OUTPORT_A20G_ENABLE


//这里发送的指令，是指令键盘控制电路的附属端口输出0xdf。这个附属端口连接着主板上的很多地方，通过这个端口发送不同的指令，就可以实现各种各样的控制功能。
//这次输出0xdf所要完成的功能，是让A20GATE信号线变成ON的状态。这条信号线的作用是什么呢？？？它能使内存1MB以上的部分变成可用状态。最初出现电脑的时候，CPU只有16位模式，所以内存最大只有1MB（ES*16+DS）。
//后来CPU变聪明了，可以使用很大的内存了。但为了兼容旧版的操作系统，在执行激活指令之前，电路被限制为智能使用1MB内存。和鼠标的情况类似，A20GATE信号线正是用来使用这个电路停止从而让所有的内存都可以使用的东西。

13.CPU家族
8086->80186->286->386->486->Pentium->PentiumPro->PentiumII->PentiumIII->Pentium4...
到286为止是16位，而386以后CPU是32位。

14.调色板颜色列表
#define COL8_000000     0   //黑
#define COL8_FF0000     1   //亮红
#define COL8_00FF00     2   //亮绿
#define COL8_FFFF00     3   //亮黄
#define COL8_0000FF     4   //亮蓝
#define COL8_FF00FF     5   //亮紫
#define COL8_00FFFF     6   //浅亮蓝
#define COL8_FFFFFF     7   //白
#define COL8_C6C6C6     8   //亮灰
#define COL8_840000     9   //暗红
#define COL8_008400     10  //暗绿
#define COL8_848400     11  //暗黄
#define COL8_000084     12  //暗青
#define COL8_840084     13  //暗紫
#define COL8_008484     14  //浅暗蓝
#define COL8_848484     15  //暗灰

15.CLI STI
CLI：将中断标志（interrupt flag）置为0的指令（clear interrupt flag）。
STI：是要将这个终端标志置为1的指令（set interrupt flag）。

16.EFLAGS
它是一个叫做EFLAGS的特殊寄存器。这是由名为FLAGS的16位寄存器扩展而来的32位寄存器。FLAGS是存储进位标志和中断标志等标志的寄存器。
进位标志可以通过JC货JNC等跳转指令来简单地判断到底是0还是1.但对于中断标志，没有类似的JI或JNI命令，所以只能读入EFLAGS，再检查第九位是0还是1.顺便说一下，进位标志是EFLAGS的第0位。

能够用来读写EFLAGS的，只有PUSHFD和POPFD指令。
PUSHFD： push flags double-word，意思是将标志位的值按双字节长压入栈。其实它所做的，就是“PUSH EFLAGS”。
POPFD： pop flags double-word, 意思是按双字节长将标志位从栈弹出。它所做的，就是“POP EFLAGS”

18.IDT
IDT是interrupt descriptor table的缩写，意思是中断记录表。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会淋湿切换过去处理这种突发事件。这就是中断功能。

中断本质上将是为了解决CPU和外部慢设备之间的问题。避免了CPU轮询的低效。

各个设备有变化时，就产生中断，中断发生后，CPU暂时停止正在处理的任务，并做好接下来继续处理的准备，转而执行中断程序。中断程序执行完后，再调用事先设定好的函数，返回处理中的任务。
正是得益于中断机制，CPU可以不用一直查询键盘、鼠标、网卡等设备的状态，将精力集中在处理任务上。

要使用鼠标，就不许使用中断。所以，我们必须设定IDT，IDT记录了0~255的中断号码于调用函数的对应关系，比如说发生了123号中断，就调用handler123()函数，其设定方法于GDT很类似。













