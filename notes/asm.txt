
10.切换32位保护模式
;   切换到保护模式

[INSTRSET "i486p"]              ; 说明使用486指令

        LGDT    [GDTR0]         ; 设置临时GDT
        MOV     EAX,CR0
        AND     EAX,0x7fffffff  ; 设bit31为0（禁用分页）
        OR      EAX,0x00000001  ; bit0到1转换（保护模式过渡）
        MOV     CR0,EAX
        JMP     pipelineflush
pipelineflush:
        MOV     AX,1*8          ;  可读写的段 32bit
        MOV     DS,AX
        MOV     ES,AX
        MOV     FS,AX
        MOV     GS,AX
        MOV     SS,AX

//LGDT,不管三七二十一，把随意准备的GDT给读进来。对于这个暂定的GDT，我们以后还要重新设置。
//然后将CR0这个特殊的32位寄存器的值带入EAX，并将最高位置为0，最低位置为1，再将这个值返回给CR0寄存器。这样就完成了模式转换，进入到不用颁的保护模式。
//保护模式与之前的16位模式不同，段寄存器的解释不是16倍，而是能够使用GDT。这里的“保护”，来自英文的“protect”。在这种模式下，应用程序既不能随便改变段的设定，又不能使用操作系统专用的段。操作系统收到CPU的保护，所以称为保护模式。在保护模式中，有带保护的16位模式，有带保护的32位模式两种。我们要使用的是带保护的32位模式。

//讲解CPU的书上会讲到，通过带入CR0而切换到保护模式时，要马上执行JMP指令。为什么呢？应为变成保护模式后，机器语言的解释要发生变化。CPU为了加快指令的执行速度而使用了管道（pipeline）的机制，就是说，前一条指令还在执行的时候，就开始解释下一条，甚至是再下一条指令。因为模式变了，需要重新解释一遍，所以加入了JMP指令。

//而且在进入保护模式后，段寄存器的意思也变了（不再是乘以16然后再加的意思），除了CS以外所有段寄存器的值都从0x0000编程了0x0008。CS保持原装是因为如果CS也变了，会造成混乱，所以只有CS要放到后面再处理。0x0008相当于“gdt+1”的段。





11. IN / OUT port
//PIC初始化相关
#define PIC0_ICW1       0x0020
#define PIC0_OCW2       0x0020
#define PIC0_IMR        0x0021
#define PIC0_ICW2       0x0021
#define PIC0_ICW3       0x0021
#define PIC0_ICW4       0x0021
#define PIC1_ICW1       0x00a0
#define PIC1_OCW2       0x00a0
#define PIC1_IMR        0x00a1
#define PIC1_ICW2       0x00a1
#define PIC1_ICW3       0x00a1
#define PIC1_ICW4       0x00a1

#define PIT_CTRL    PU0x0043//PIT timer
#define PIT_CNT0    0x0040//PIT timer

0x60 PORT_KEYDAT//键盘
0x64 PORT_KEYSTA//键盘控制电路
0x64 PORT_KEYCMD//键盘

0x03c7//读调色板号
0x03c8//写调色板号
0x03c9//调色板RGB数据
//将想要设定的调色板号码写入0x03c8,紧接着，按R,G,B的顺序写入0x03c9。
//如果想要读出当前调色板的状态，首先要将调色板的好吗写入0x03c7，再从0x03c9读取三次。

12. IN / OUT comand
0x02 —— KEYSTA_SEND_NOTREADY//if (io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY == 0)
0x47 —— KBC_MODE
0x60 —— KEYCMD_WRITE_MODE

void wait_KBC_sendready(void) {
    /* 等待键盘控制电路准备完毕 */
    for (;;) {
        if ((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0) {
            break;
        }
    }
    return;
}

//让键盘控制电路做好准备工作，等待控制指令的到来。如果键盘电路可以接受CPU指令了，CPU从设备号码0x0064处所读取的数据的倒数第二位应该是0.在确认到这一位是0之前，程序一直通过for语句循环查询。

void init_keyboard(void) {
    /* 初始化键盘控制电路 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, KBC_MODE);
    return;
}

//一边确认可否往键盘控制电路发送信息，一步安发送模式指定指令，指令中包含着设定为何种模式。模式设定的指令是0x60，利用鼠标模式的模式号码是0x47.

#define KEYCMD_SENDTO_MOUSE   0xd4
#define MOUSECMD_ENABLE     0xf4
void enable_mouse(struct MOUSE_DEC *mdec) {
    /* 鼠标有效 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);
    /* 顺利的话，ACK(0xfa)会被送过来 */
    mdec->phase = 0; /* 等待0xfa的阶段 */
    return;
}

//如果往键盘控制电路发送0xd4指令，下一个数据就会自动发给鼠标。我们根据这一特性来发送激活鼠标的指令。
//另一方面，鼠标收到激活指令以后，马上就给CPU发送答复信息，这个答复信息就是oxfa。


0xd1 —— KEYCMD_WRITE_OUTPORT  //
0xdf —— KBC_OUTPORT_A20G_ENABLE

;   为了让CPU能够访问1MB以上的内存空间，设定A20GATE

        CALL    waitkbdout
        MOV     AL,0xd1
        OUT     0x64,AL
        CALL    waitkbdout
        MOV     AL,0xdf         ; enable A20
        OUT     0x60,AL
        CALL    waitkbdout

/*A20GATE的设定*/
wait_KBC_sendready();
io_out8(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);
wait_KBC_sendready();
io_out8(PORT_KEYDAT, KBC_OUTPORT_A20G_ENABLE);
wait_KBC_sendready();


//这里发送的指令，是指令键盘控制电路的附属端口输出0xdf。这个附属端口连接着主板上的很多地方，通过这个端口发送不同的指令，就可以实现各种各样的控制功能。
//这次输出0xdf所要完成的功能，是让A20GATE信号线变成ON的状态。这条信号线的作用是什么呢？？？它能使内存1MB以上的部分变成可用状态。最初出现电脑的时候，CPU只有16位模式，所以内存最大只有1MB（ES*16+DS）。
//后来CPU变聪明了，可以使用很大的内存了。但为了兼容旧版的操作系统，在执行激活指令之前，电路被限制为智能使用1MB内存。和鼠标的情况类似，A20GATE信号线正是用来使用这个电路停止从而让所有的内存都可以使用的东西。

13.CPU家族
8086->80186->286->386->486->Pentium->PentiumPro->PentiumII->PentiumIII->Pentium4...
到286为止是16位，而386以后CPU是32位。




19.CPU关闭缓存
unsigned int memtest(unsigned int start, unsigned int end)
{
    char flg486 = 0;
    unsigned int eflg, cr0, i;

    /* 确认CPU是386还是486以上的 */
    eflg = io_load_eflags();
    eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */
    io_store_eflags(eflg);
    eflg = io_load_eflags();
    if ((eflg & EFLAGS_AC_BIT) != 0) {
        /* 如果是386，即使设定AC=1，AC的值还会自动回到0 */
        flg486 = 1;
    }

    eflg &= ~EFLAGS_AC_BIT; /* AC-bit = 0 */
    io_store_eflags(eflg);

    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */
        store_cr0(cr0);
    }

    i = memtest_sub(start, end);

    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 &= ~CR0_CACHE_DISABLE; /* 允许缓存 */
        store_cr0(cr0);
    }

    return i;
}

//最初是对EFLAGS的处理，检查CPU是486以上还是386.如果是486以上，EFLAGS寄存器的第18位应该是所谓的AC标志位；如果CPU是386，则没有这个标志位。
//为了禁止缓存，需要对CR0寄存器的某一标志位进行操作。对哪里操作，怎么操作，大家一看程序就能明白。

20.bit操作取反操作
C语言：eflag &= ~EFLAGS_AC_BIT;
ASM： XOR DWORD [EBX], 0xffffffff




25.PIT
PIT "Programmable Interval Timer".可编程的间隔型定时器。
我们通过设定PIT，让定时器每隔多少秒就产生一次中断。因为在电脑中PIT连接着IRQ的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。
在旧机器上PPIT是作为一个独立的芯片安装在主板上的，而现在已经和PIC一样被集成到别的芯片中了。

#define PIT_CTRL    0x0043
#define PIT_CNT0    0x0040
void init_pit(void)
{
    int i;
    io_out8(PIT_CTRL, 0x34);
    io_out8(PIT_CNT0, 0x9c);
    io_out8(PIT_CNT0, 0x2e);
    timerctl.count = 0;
    timerctl.next = 0xffffffff; /* 因为最初没有正在运行的定时器 */
    timerctl.using = 0;
    for (i = 0; i < MAX_TIMER; i++) {
    timerctl.timers0[i].flags = 0; /* 未使用 */
    }
    return;
}

26.切换到高分屏
        MOV     BX,0x4101; VBE的640*480*8bi彩色
        MOV     AX,0x4f02
        INT     0x10
        MOV     BYTE [VMODE],8
        MOV     WORD [SCRNX],640
        MOV     WORD [SCRNY],480
        MOV     DWORD [VRAM], 0xe00000000

以前画面是320*200的时候，AH=0，AL=画面模式号码。
切换到VBE的画面模式：AX=0x4f02，BX=画面模式号码。

0x101      640*480* 8bit彩色
0x103       800*600
0x105       1024*768
0x107       1280*1024

在QEMU中不能指定最下面的0x107，实际指定的时候，要像在asmhead.nas中所做的那样，将以上的画面模式号码加上0x4000，再赋值到BX中去，不这样做就不能顺利运行。


27.画面模式中的重要信息
WORD    【ES: DI + 0x00】：模式属性    bit7不是1就不好办（能加上0x4000）
WORD    【ES: DI + 0x12】：X的分辨率
WORD    【ES: DI + 0x14】：Y的分辨率
BYTE    【ES: DI + 0x19】：颜色数，必须为8
BYTE    【ES: DI + 0x1b】：颜色的指定方法。必须为4（4是调色板模式）
DWORD   【ES: DI + 0x28】：VRAM的地址。

28.VBE
 VESA BIOS extension， VESA-BIOS扩展，简称VBE。利用它，就可以提高显卡分辨率了。

29.任务切换一些背景
一般操作系统每个切换间隔是0.01~0.03秒
切换动作本身需要消耗0.0001秒。

当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。
接下来，为了运行下一个程序，CPU会把所有的寄存器的值从内存中读出来，这样就完成了一次切换。

30.TSS

任务状态段，Task Status Segment

struct TSS32 {
    int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;         //任务设置相关信息
    int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;    //32位寄存器
    int es, cs, ss, ds, fs, gs;                                 //16位寄存器
    int ldtr, iomap;                                            //任务设置相关
};

第一行：
任务设置相关信息，在执行任务切换的时候这些成员不会被写入。

第二行：
32位寄存器

第三行：
16位寄存器

第四行：
任务设置相关。ldtr = 0，iomap = 0x400000000









 











