3.操作系统对内存的使用
0x00000000 ~ 0x000fffff: 虽然在启动中会多次使用，但之后就变空。（1MB）
--------------------------------------------
--0地址：BOIS程序用来实现各种功能的地方。
--0x00000ff0: BOOTINFO
; BOOT_INFO相关
CYLS    EQU     0x0ff0          ; 引导扇区设置
LEDS    EQU     0x0ff1
VMODE   EQU     0x0ff2          ; 关于颜色的信息
SCRNX   EQU     0x0ff4          ; 分辨率X
SCRNY   EQU     0x0ff6          ; 分辨率Y
VRAM    EQU     0x0ff8          ; 图像缓冲区的起始地址
--0x00007c00~~0x00007dff:启动区内容的装载地址。(IPL，IBM大叔规定的，MOV SP,0x7c00)//fake os装载地址。SP指向的地方。并不是代码段的地方？？？？
--0x00008000:软盘磁盘内容拷贝到内存的地址。//拷贝的地址和真正的装载地址不是一回事。磁盘的第一个sector是启动区代码，BIOS直接转载到7c00.可能会拷贝到8000.
--0x00008000 ~ 0x000081ff  启动区内容（启动区和装载器的区别？？？？？？？）
--0x00008200 ~ 0x000083ff （IPL，启动程序装载器）
--0x0000c200:操作系统地址(OS)//asmhead装载地址 ORG     0xc200
--0x000a0000~~0x000affff:VRAM显卡内存地址（64KB）
--0x000f0000地址：存放这BIOS程序本身
--------------------------------------------
--0x00100000 ~ 0x00267fff: 用于保存软盘的内容（1440KB）
--0x00268000 ~ 0x0026f7ff: 空（30KB）
--0x0026f800 ~ 0x0026ffff: IDT（2KB）
--0x00270000 ~ 0x0027ffff: GDT（64KB）
--0x00280000 ~ 0x002fffff: bootpack.hrb（512KB）
--0x00300000 ~ 0x003fffff: 栈及其它（1MB）
--0x00400000 ~ NIL       ：空


0x7c00，是ipl的运行地址。
0x8000，是ipl代码内容的拷贝地址。
0xc200，真正操作系统代码的地址。运行地址？？这部分包括asmhead.nas + bootpack.c。

现在的程序从启动区开始，把磁盘上的内容装载到内存0x8000号地址，所以磁盘的0x4200处的内容，就是位于内存0x8000+0x4200 = 0xc200号地址。是真正操作系统的代码地址。
所以ORG的意思，就是将二进制代码段部署到某个内存地址。


4.BIOS中断和DOS中断的区别
bios是主板预装好的input、output系统，而dos是需要安装才能使用操作系统。用int条用中断以后可以通过不同的系统达到不同的目的和效果。其中int 1 -20 是bios中断，int21 专门用于dos中断。
只有16位汇编才能访问BIOS，32位汇编不能访问。

电脑里有个名为BIOS的程序，出厂时就组装在电脑主板上的ROM单元里。电脑厂家在BIOS里预先写入了操作系统开发人员经常会用到的一些程序。

最近的BIOS功能非常多，设置包括了电脑的设定画面，不过它的本质正如其名，就是操作系统开发人员准备的各种函数的集合。而INT就是用来调用这些函数的指令。
INT后面是个数字，不同的数字可以调用不同的函数。这次我们调用的是0x10(即16)号函数，它的功能是控制显卡。

5.如果汇编和C语言联合使用的话，有的寄存器可以自由使用，有的寄存器不能自由使用，能自由使用的只有eax, ecx, edx,这三个。至于其它寄存器，智能使用其值，而不能改变其值。
因为这些寄存器在c语言编译后生成的机器语言中，用于记忆非常重要的值。


7.GDT，分段
分段使用段寄存器。16位的时候，如果计算地址，只要将地址乘以16就可以了。
但现在是32位，如果写成“MOV AL,[DS:EBX]”，地址计算是DS+EBX，不再需要DS乘以16. 如果省略DS的地址，也会认为指定了DS，为0.

按照这种分段方法，为了表示一个段，需要以下信息。
--段的大小
--段的起始地址
--段的管理属性（禁止写入，禁止执行，系统专用等）
CPU用8个字节（64bit）来表示这些信息。但是用于指定段的寄存器只有16位。
段号可以用0~8191的数。因为段寄存器是16位，本来可以处理0~65535范围的数，但由于CPU设计上的原因，段寄存器的低三位不能使用。因此能够使用的部分只有13位，能够处理的就只有位于0~8191的段了。

所以管理这么多段的元数据就需要 8192*8 = 64KB。
CPU没那么大存储能力，不可能存储这么多数据，需要写入内存。这64KB的数据就成为GDT。

GDT 是 global segment descriptor table的缩写，意思是全局段号记录表。将这些数据整齐地排列在内存的某个地方，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。

--段起始地址：32位表示，low（2byte），mid（1byte），high（1byte）
--段上限：只能使用20位，原则上段上限最大指定1MB。所以这里有一个trick，在段的属性里设置了一个标志位，叫做Gbit。这个标志位是1的时候，limit的单位不解释成字节byte，而是解释成页page。
    这样一来，4K * 1MB = 4GB，所以可以指定4G的段。 limit_low(2byte), limit_high(0.5byte = 4bit)
--段属性：12bit，高4位放在limit_high的高4位里，ar有16bit。
    --高4位：扩展访问权。这四位在286时代没有，386才开始。这四位是由“GD00”构成，G是指刚才所说的Gbit，D是指段的模式，1是指32位模式，0是指16位模式。
    --低8位：
        --00000000（0x00）：未使用的记录表
        --10010010（0x92）：系统专用，可读写的段。不可执行。
        --10011010（0x9a）：系统专用，可执行的段。可读不可写。
        --11110010（0xf2）：应用程序用，可读写的段，不可执行。
        --11111010（0xfa）：应用程序用，可执行的段，可读不可写。
        CPU到底处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权为0x9a的段，还是0xfa的段。

8.IDT
IDT是“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会临时切花过去处理这种突发事件。这就是中断功能。

IDT记录了0~255的中断号码和调用函数的对应关系。

9.PIC
PIC:programmable interrupt controller.) 可编程中断控制器。
IMR: interrupt mask register, 中断屏蔽寄存器（8位）
ICW: initial control word. 初始化控制数据（8位）

CPU只能处理一个中断，不够用，所以IBM在主板上增加了辅助芯片。现在他们已经被集成到一个芯片组里了。

PIC是将8个中断信号集合成一个中断信号的装置。PIC监视着输入管教的8个中断信号。只要有一个中断信号进来，就将唯一的输出管教信号变成ON，并通知给CPU。IBM想要通过增加PIC来处理更多的中断信号，因为电脑上会有8个以上的外部设备，所以就把中断信号设计成15个，并为此增设了两个PIC。

与CPU直接相连的PIC是主PIC，与主PIC相连的PIC是从PIC。主PIC负责处理0号到7号的中断信号，从PIC负责处理从8号到15号的中断信号。
另外，从PIC通过2号IRQ与主PIC相连。

void init_pic(void)
/* PIC初始化 */
{
    io_out8(PIC0_IMR,  0xff  ); /* 禁止所有中断 */
    io_out8(PIC1_IMR,  0xff  ); /* 禁止所有中断 */

    io_out8(PIC0_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC0_ICW2, 0x20  ); /* IRQ0-7由INT20-27接收 */
    io_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2相连 */
    io_out8(PIC0_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC1_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC1_ICW2, 0x28  ); /* IRQ8-15由INT28-2f接收 */
    io_out8(PIC1_ICW3, 2     ); /* PIC1由IRQ2连接 */
    io_out8(PIC1_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC0_IMR,  0xfb  ); /* 11111011 PIC1以外全部禁止 */
    io_out8(PIC1_IMR,  0xff  ); /* 11111111 禁止所有中断 */

    return;
}


IMR: interrupt mask register, 中断屏蔽寄存器。
8位分别对应8路IRQ信号。如果某一位的值是1，则该位所对应的IRQ信号被屏蔽，PIC就忽略该信号。

ICW: initial control word. 初始化控制数据
ICW有4个，分别编号为1~4，共有4个字节的数据。

INT0x20~0x2f接收中断信号IRQ0~15，INT 0x00~0x1f不能用。当应用程序想要干坏事的时候，CPU内部会自动产生INT0x00~0x1f，如果IRQ与这些号码重复了，CPU就分不清它到底是IRQ，还是CPU的系统保护通知。

鼠标是IRQ12，键盘是IRQ1
所以用int 0x2c 和int 0x21的中断处理程序来处理二者的中断。



10.切换32位保护模式
;   切换到保护模式

[INSTRSET "i486p"]              ; 说明使用486指令

        LGDT    [GDTR0]         ; 设置临时GDT
        MOV     EAX,CR0
        AND     EAX,0x7fffffff  ; 设bit31为0（禁用分页）
        OR      EAX,0x00000001  ; bit0到1转换（保护模式过渡）
        MOV     CR0,EAX
        JMP     pipelineflush
pipelineflush:
        MOV     AX,1*8          ;  可读写的段 32bit
        MOV     DS,AX
        MOV     ES,AX
        MOV     FS,AX
        MOV     GS,AX
        MOV     SS,AX

//LGDT,不管三七二十一，把随意准备的GDT给读进来。对于这个暂定的GDT，我们以后还要重新设置。
//然后将CR0这个特殊的32位寄存器的值带入EAX，并将最高位置为0，最低位置为1，再将这个值返回给CR0寄存器。这样就完成了模式转换，进入到不用颁的保护模式。
//保护模式与之前的16位模式不同，段寄存器的解释不是16倍，而是能够使用GDT。这里的“保护”，来自英文的“protect”。在这种模式下，应用程序既不能随便改变段的设定，又不能使用操作系统专用的段。操作系统收到CPU的保护，所以称为保护模式。在保护模式中，有带保护的16位模式，有带保护的32位模式两种。我们要使用的是带保护的32位模式。

//讲解CPU的书上会讲到，通过带入CR0而切换到保护模式时，要马上执行JMP指令。为什么呢？应为变成保护模式后，机器语言的解释要发生变化。CPU为了加快指令的执行速度而使用了管道（pipeline）的机制，就是说，前一条指令还在执行的时候，就开始解释下一条，甚至是再下一条指令。因为模式变了，需要重新解释一遍，所以加入了JMP指令。

//而且在进入保护模式后，段寄存器的意思也变了（不再是乘以16然后再加的意思），除了CS以外所有段寄存器的值都从0x0000编程了0x0008。CS保持原装是因为如果CS也变了，会造成混乱，所以只有CS要放到后面再处理。0x0008相当于“gdt+1”的段。





11. IN / OUT port
//PIC初始化相关
#define PIC0_ICW1       0x0020
#define PIC0_OCW2       0x0020
#define PIC0_IMR        0x0021
#define PIC0_ICW2       0x0021
#define PIC0_ICW3       0x0021
#define PIC0_ICW4       0x0021
#define PIC1_ICW1       0x00a0
#define PIC1_OCW2       0x00a0
#define PIC1_IMR        0x00a1
#define PIC1_ICW2       0x00a1
#define PIC1_ICW3       0x00a1
#define PIC1_ICW4       0x00a1

#define PIT_CTRL    PU0x0043//PIT timer
#define PIT_CNT0    0x0040//PIT timer

0x60 PORT_KEYDAT//键盘
0x64 PORT_KEYSTA//键盘控制电路
0x64 PORT_KEYCMD//键盘

0x03c7//读调色板号
0x03c8//写调色板号
0x03c9//调色板RGB数据
//将想要设定的调色板号码写入0x03c8,紧接着，按R,G,B的顺序写入0x03c9。
//如果想要读出当前调色板的状态，首先要将调色板的好吗写入0x03c7，再从0x03c9读取三次。

12. IN / OUT comand
0x02 —— KEYSTA_SEND_NOTREADY//if (io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY == 0)
0x47 —— KBC_MODE
0x60 —— KEYCMD_WRITE_MODE

void wait_KBC_sendready(void) {
    /* 等待键盘控制电路准备完毕 */
    for (;;) {
        if ((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0) {
            break;
        }
    }
    return;
}

//让键盘控制电路做好准备工作，等待控制指令的到来。如果键盘电路可以接受CPU指令了，CPU从设备号码0x0064处所读取的数据的倒数第二位应该是0.在确认到这一位是0之前，程序一直通过for语句循环查询。

void init_keyboard(void) {
    /* 初始化键盘控制电路 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, KBC_MODE);
    return;
}

//一边确认可否往键盘控制电路发送信息，一步安发送模式指定指令，指令中包含着设定为何种模式。模式设定的指令是0x60，利用鼠标模式的模式号码是0x47.

#define KEYCMD_SENDTO_MOUSE   0xd4
#define MOUSECMD_ENABLE     0xf4
void enable_mouse(struct MOUSE_DEC *mdec) {
    /* 鼠标有效 */
    wait_KBC_sendready();
    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);
    wait_KBC_sendready();
    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);
    /* 顺利的话，ACK(0xfa)会被送过来 */
    mdec->phase = 0; /* 等待0xfa的阶段 */
    return;
}

//如果往键盘控制电路发送0xd4指令，下一个数据就会自动发给鼠标。我们根据这一特性来发送激活鼠标的指令。
//另一方面，鼠标收到激活指令以后，马上就给CPU发送答复信息，这个答复信息就是oxfa。


0xd1 —— KEYCMD_WRITE_OUTPORT  //
0xdf —— KBC_OUTPORT_A20G_ENABLE

;   为了让CPU能够访问1MB以上的内存空间，设定A20GATE

        CALL    waitkbdout
        MOV     AL,0xd1
        OUT     0x64,AL
        CALL    waitkbdout
        MOV     AL,0xdf         ; enable A20
        OUT     0x60,AL
        CALL    waitkbdout

/*A20GATE的设定*/
wait_KBC_sendready();
io_out8(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);
wait_KBC_sendready();
io_out8(PORT_KEYDAT, KBC_OUTPORT_A20G_ENABLE);
wait_KBC_sendready();


//这里发送的指令，是指令键盘控制电路的附属端口输出0xdf。这个附属端口连接着主板上的很多地方，通过这个端口发送不同的指令，就可以实现各种各样的控制功能。
//这次输出0xdf所要完成的功能，是让A20GATE信号线变成ON的状态。这条信号线的作用是什么呢？？？它能使内存1MB以上的部分变成可用状态。最初出现电脑的时候，CPU只有16位模式，所以内存最大只有1MB（ES*16+DS）。
//后来CPU变聪明了，可以使用很大的内存了。但为了兼容旧版的操作系统，在执行激活指令之前，电路被限制为智能使用1MB内存。和鼠标的情况类似，A20GATE信号线正是用来使用这个电路停止从而让所有的内存都可以使用的东西。

13.CPU家族
8086->80186->286->386->486->Pentium->PentiumPro->PentiumII->PentiumIII->Pentium4...
到286为止是16位，而386以后CPU是32位。

14.调色板颜色列表
自己定义的，也可以不是这样。
#define COL8_000000     0   //黑
#define COL8_FF0000     1   //亮红
#define COL8_00FF00     2   //亮绿
#define COL8_FFFF00     3   //亮黄
#define COL8_0000FF     4   //亮蓝
#define COL8_FF00FF     5   //亮紫
#define COL8_00FFFF     6   //浅亮蓝
#define COL8_FFFFFF     7   //白
#define COL8_C6C6C6     8   //亮灰
#define COL8_840000     9   //暗红
#define COL8_008400     10  //暗绿
#define COL8_848400     11  //暗黄
#define COL8_000084     12  //暗青
#define COL8_840084     13  //暗紫
#define COL8_008484     14  //浅暗蓝
#define COL8_848484     15  //暗灰

15.CLI STI
CLI：将中断标志（interrupt flag）置为0的指令（clear interrupt flag）。
STI：是要将这个终端标志置为1的指令（set interrupt flag）。

16.EFLAGS
它是一个叫做EFLAGS的特殊寄存器。这是由名为FLAGS的16位寄存器扩展而来的32位寄存器。FLAGS是存储进位标志和中断标志等标志的寄存器。
进位标志可以通过JC货JNC等跳转指令来简单地判断到底是0还是1.但对于中断标志，没有类似的JI或JNI命令，所以只能读入EFLAGS，再检查第九位是0还是1.顺便说一下，进位标志是EFLAGS的第0位。

能够用来读写EFLAGS的，只有PUSHFD和POPFD指令。
PUSHFD： push flags double-word，意思是将标志位的值按双字节长压入栈。其实它所做的，就是“PUSH EFLAGS”。
POPFD： pop flags double-word, 意思是按双字节长将标志位从栈弹出。它所做的，就是“POP EFLAGS”

18.IDT
IDT是interrupt descriptor table的缩写，意思是中断记录表。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会淋湿切换过去处理这种突发事件。这就是中断功能。

中断本质上将是为了解决CPU和外部慢设备之间的问题。避免了CPU轮询的低效。

各个设备有变化时，就产生中断，中断发生后，CPU暂时停止正在处理的任务，并做好接下来继续处理的准备，转而执行中断程序。中断程序执行完后，再调用事先设定好的函数，返回处理中的任务。
正是得益于中断机制，CPU可以不用一直查询键盘、鼠标、网卡等设备的状态，将精力集中在处理任务上。

要使用鼠标，就不许使用中断。所以，我们必须设定IDT，IDT记录了0~255的中断号码于调用函数的对应关系，比如说发生了123号中断，就调用handler123()函数，其设定方法于GDT很类似。


19.CPU关闭缓存
unsigned int memtest(unsigned int start, unsigned int end)
{
    char flg486 = 0;
    unsigned int eflg, cr0, i;

    /* 确认CPU是386还是486以上的 */
    eflg = io_load_eflags();
    eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */
    io_store_eflags(eflg);
    eflg = io_load_eflags();
    if ((eflg & EFLAGS_AC_BIT) != 0) {
        /* 如果是386，即使设定AC=1，AC的值还会自动回到0 */
        flg486 = 1;
    }

    eflg &= ~EFLAGS_AC_BIT; /* AC-bit = 0 */
    io_store_eflags(eflg);

    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */
        store_cr0(cr0);
    }

    i = memtest_sub(start, end);

    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 &= ~CR0_CACHE_DISABLE; /* 允许缓存 */
        store_cr0(cr0);
    }

    return i;
}

//最初是对EFLAGS的处理，检查CPU是486以上还是386.如果是486以上，EFLAGS寄存器的第18位应该是所谓的AC标志位；如果CPU是386，则没有这个标志位。
//为了禁止缓存，需要对CR0寄存器的某一标志位进行操作。对哪里操作，怎么操作，大家一看程序就能明白。

20.bit操作取反操作
C语言：eflag &= ~EFLAGS_AC_BIT;
ASM： XOR DWORD [EBX], 0xffffffff

21.作者编译程序顺序
asm->making-->run

c文件：c语言文件。
gas文件：c语言生成的汇编语言，只不过是gcc版的asm，不是作者用的nas汇编。（$(CC1) cc1.exe -o bootpack.gas bootpack.c）
nas文件：汇编语言文件，类似于ASM。gas文件可以生成nas文件。（$(GAS2NASK) gas2nask.exe bootpack.gas bootpack.nas）
obj文件：目标文件，nas文件生成。（$(NASK) nask.exe bootpack.nas bootpack.obj bootpack.lst）
bim文件：obj文件生成bim文件。经过link操作的二进制文件。（$(OBJ2BIM) obj2bim.exe @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map bootpack.obj naskfunc.obj）
//问题？？bim和obj，bin的关系？？？？？？？
hrb文件：bim生成hrb文件。在bim的基础上，还需要针对每一种操作系统的要求进行必要的加工，比如加上识别用的文件头，或者压缩等。($(BIM2HRB) bim2hrb.exe bootpack.bim bootpack.hrb 0)

bin文件：二进制文件，nas文件生成。但是这个文件不能和目标文件连接，因为它不是目标文件。还要加上连接所需要的接口信息，将它变为目标文件。这项工作由bin2obj.exe完成。
sys文件：hrb文件+ asmhead.bin文件生成，操作系统的全部代码（haribote.sys : asmhead.bin bootpack.hrb Makefile  ———— copy /B asmhead.bin+bootpack.hrb haribote.sys）
img文件：真正的镜像文件，可执行文件。sys文件+ipl.bin。（haribote.img : ipl10.bin haribote.sys Makefile
    $(EDIMG)   imgin:../z_tools/fdimg0at.tek \
        wbinimg src:ipl10.bin len:512 from:0 to:0 \
        copy from:haribote.sys to:@: \
        imgout:haribote.img）

lst文件：文本文件，简单的确认每个指令是怎样翻译成机器语言的。（../z_tools/nask.exe ipl.nas ipl.bin ipl.lst）



推导规则：
nask.exe: *.nas-->*.bin
edimg.exe: *.bin --> *.img

run:
    copy helloos.img ..\z_tools\qemu\fdimage0.bin
    ../z_tools/make.exe -C ../z_tools/qemu

install://暂时用不到，用于真正的windows机器。我们用虚拟机，所以make run就可以。
    ../z_tools/make.exe img
    ../z_tools/imgtol.com w a: helloos.img



23.INT——中断
(1)INT 0x10——调用显卡BIOS
AH:0x00 :设置显卡模式。AL指定模式。
AH:0x0e ：显示一个文字。BX指定文字颜色。

(2)INT 0x13——磁盘读写，扇区校验(verify)，以及寻道(seek)。具体参数查阅百度
AH:0x00 :系统复位
AH:0x02 :读盘
AH:0x03 :写盘
AH:0x04 :校验
AH:0x0c :寻道

(3)INT 0x20：定时器
(4)INT 0x21
(5)INT 0x27
(6)INT 0x2c

24.操作系统端对齐
esp     -> 0xff
esp+1   -> 0xff
esp+2   -> 0x00
esp+3   -> 0x00
esp+4   ->

一个int 4字节变量 var = 【esp+4】 = 0x0000ffff
注意存储顺序。
读数据从后往前读取。


栈的内存，从高到低放入数据，取数据从低到高。


函数的第一个参数是ESP+4



25.PIT
PIT "Programmable Interval Timer".可编程的间隔型定时器。
我们通过设定PIT，让定时器每隔多少秒就产生一次中断。因为在电脑中PIT连接着IRQ的0号，所以只要设定了PIT就可以设定IRQ0的中断间隔。
在旧机器上PPIT是作为一个独立的芯片安装在主板上的，而现在已经和PIC一样被集成到别的芯片中了。

#define PIT_CTRL    0x0043
#define PIT_CNT0    0x0040
void init_pit(void)
{
    int i;
    io_out8(PIT_CTRL, 0x34);
    io_out8(PIT_CNT0, 0x9c);
    io_out8(PIT_CNT0, 0x2e);
    timerctl.count = 0;
    timerctl.next = 0xffffffff; /* 因为最初没有正在运行的定时器 */
    timerctl.using = 0;
    for (i = 0; i < MAX_TIMER; i++) {
    timerctl.timers0[i].flags = 0; /* 未使用 */
    }
    return;
}

26.切换到高分屏
        MOV     BX,0x4101; VBE的640*480*8bi彩色
        MOV     AX,0x4f02
        INT     0x10
        MOV     BYTE [VMODE],8
        MOV     WORD [SCRNX],640
        MOV     WORD [SCRNY],480
        MOV     DWORD [VRAM], 0xe00000000

以前画面是320*200的时候，AH=0，AL=画面模式号码。
切换到VBE的画面模式：AX=0x4f02，BX=画面模式号码。

0x101      640*480* 8bit彩色
0x103       800*600
0x105       1024*768
0x107       1280*1024

在QEMU中不能指定最下面的0x107，实际指定的时候，要像在asmhead.nas中所做的那样，将以上的画面模式号码加上0x4000，再赋值到BX中去，不这样做就不能顺利运行。


27.画面模式中的重要信息
WORD    【ES: DI + 0x00】：模式属性    bit7不是1就不好办（能加上0x4000）
WORD    【ES: DI + 0x12】：X的分辨率
WORD    【ES: DI + 0x14】：Y的分辨率
BYTE    【ES: DI + 0x19】：颜色数，必须为8
BYTE    【ES: DI + 0x1b】：颜色的指定方法。必须为4（4是调色板模式）
DWORD   【ES: DI + 0x28】：VRAM的地址。

28.VBE
 VESA BIOS extension， VESA-BIOS扩展，简称VBE。利用它，就可以提高显卡分辨率了。

29.任务切换一些背景
一般操作系统每个切换间隔是0.01~0.03秒
切换动作本身需要消耗0.0001秒。

当你向CPU发出任务切换的指令时，CPU会先把寄存器中的值全部写入内存，这样做是为了当以后切换回这个程序的时候，可以从中断的地方继续运行。
接下来，为了运行下一个程序，CPU会把所有的寄存器的值从内存中读出来，这样就完成了一次切换。

30.TSS

任务状态段，Task Status Segment

struct TSS32 {
    int backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3;         //任务设置相关信息
    int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;    //32位寄存器
    int es, cs, ss, ds, fs, gs;                                 //16位寄存器
    int ldtr, iomap;                                            //任务设置相关
};

第一行：
任务设置相关信息，在执行任务切换的时候这些成员不会被写入。

第二行：
32位寄存器

第三行：
16位寄存器

第四行：
任务设置相关。ldtr = 0，iomap = 0x400000000


32.段的概念
所有的段，都在GDT注册
每个段的大小不一定是64KB

33.



 











