1.各种寄存器
AX--accumulator, 累加寄存器
CS--counter，计数寄存器
DX--data，数据寄存器
BX--base，基址寄存器
SP--stack pointer，栈指针寄存器
BP——base pointer，基址指针寄存器
SI--source index，源变址寄存器
DI——destination index，目的变址寄存器


ES——附加段寄存器(extra segment)
CS——代码段寄存器(code segment)
SS——栈段寄存器(stack segment)
DS——数据段寄存器(data segment)
FS——没有名称（segment part 2）
GS——没有名称（segment part 3）

CR0——特殊的32位寄存器，也就是control register 0，是一个非常重要的寄存器，只有操作系统才能使用。

2.寄存器限制
只有BX、BP、SI、DI几个寄存器，可以用寄存器指定内存地址，剩下的AX、CX、DX、SP不可以。
C语言和汇编联合使用的时候，EAX, ECX, EDX这几个寄存器可以随便使用，其它寄存器只能读，不能写。因为其它寄存器在编译C语言时，用来存重要的值。

3.操作系统对内存的使用
0x00000000 ~ 0x000fffff: 虽然在启动中会多次使用，但之后就变空。（1MB）
--------------------------------------------
--0地址：BOIS程序用来实现各种功能的地方。
--0x00000ff0: BOOTINFO
--0x00007c00~~0x00007dff:启动区内容的装载地址。(IPL)
--0x00008000:磁盘内容拷贝到内存的地址。
--0x0000c200:操作系统地址(OS)
--0x000a0000~~0x000affff:VRAM显卡内存地址
--0x000f0000地址：存放这BIOS程序本身
--------------------------------------------
--0x00100000 ~ 0x00267fff: 用于保存软盘的内容（1440KB）
--0x00268000 ~ 0x0026f7ff: 空（30KB）
--0x0026f800 ~ 0x0026ffff: IDT（2KB）
--0x00270000 ~ 0x0027ffff: GDT（64KB）
--0x00280000 ~ 0x002fffff: bootpack.hrb（512KB）
--0x00300000 ~ 0x003fffff: 栈及其它（1MB）
--0x00400000 ~ NIL       ：空


4.BIOS中断和DOS中断的区别
bios是主板预装好的input、output系统，而dos是需要安装才能使用操作系统。用int条用中断以后可以通过不同的系统达到不同的目的和效果。其中int 1 -20 是bios中断，int21 专门用于dos中断。
只有16位汇编才能访问BIOS，32位汇编不能访问。

5.如果汇编和C语言联合使用的话，有的寄存器可以自由使用，有的寄存器不能自由使用，能自由使用的只有eax, ecx, edx,这三个。至于其它寄存器，智能使用其值，而不能改变其值。
因为这些寄存器在c语言编译后生成的机器语言中，用于记忆非常重要的值。

6.新指令
（1）INSTRSET指令
    [INSTRSET "i486p"]              ; 使用到486为止的指令，为了能够使用386以后的LGDT，EAX，CR0等关键字。
（2）LGDT，读取GDT
（3）ALIGNB 16，一直添加DB 0，直到地址被16整除。
（4）PUSHFD，POPFD；读写EFLAGS的指令

7.GDT
GDT是“global segment descriptor table“的缩写，意思是全局短号记录表。大小64K（8192*8 = 64K）
将这些数据整齐地排列在内存的某个地方，然后将内存的起始地址和有效设定个数放在CPU内被称作GDTR的特殊寄存器中，设定就完成了。

8.IDT
IDT是“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会临时切花过去处理这种突发事件。这就是中断功能。

IDT记录了0~255的中断号码和调用函数的对应关系。

9.PIC
PIC:programmable interrupt controller.) 可编程中断控制器。
IMR: interrupt mask register, 中断屏蔽寄存器
ICW: initial control word. 初始化控制数据

10.切换32位保护模式
;   切换到保护模式

[INSTRSET "i486p"]              ; 说明使用486指令

        LGDT    [GDTR0]         ; 设置临时GDT
        MOV     EAX,CR0
        AND     EAX,0x7fffffff  ; 设bit31为0（禁用分页）
        OR      EAX,0x00000001  ; bit0到1转换（保护模式过渡）
        MOV     CR0,EAX
        JMP     pipelineflush
pipelineflush:
        MOV     AX,1*8          ;  可读写的段 32bit
        MOV     DS,AX
        MOV     ES,AX
        MOV     FS,AX
        MOV     GS,AX
        MOV     SS,AX

//LGDT,不管三七二十一，把随意准备的GDT给读进来。对于这个暂定的GDT，我们以后还要重新设置。
//然后将CR0这个特殊的32位寄存器的值带入EAX，并将最高位置为0，最低位置为1，再将这个值返回给CR0寄存器。这样就完成了模式转换，进入到不用颁的保护模式。
//保护模式与之前的16位模式不同，段寄存器的解释不是16倍，而是能够使用GDT。这里的“保护”，来自英文的“protect”。在这种模式下，应用程序既不能随便改变段的设定，又不能使用操作系统专用的段。操作系统收到CPU的保护，所以称为保护模式。在保护模式中，有带保护的16位模式，有带保护的32位模式两种。我们要使用的是带保护的32位模式。

//讲解CPU的书上会讲到，通过带入CR0而切换到保护模式时，要马上执行JMP指令。为什么呢？应为变成保护模式后，机器语言的解释要发生变化。CPU为了加快指令的执行速度而使用了管道（pipeline）的机制，就是说，前一条指令还在执行的时候，就开始解释下一条，甚至是再下一条指令。因为模式变了，需要重新解释一遍，所以加入了JMP指令。

//而且在进入保护模式后，段寄存器的意思也变了（不再是乘以16然后再加的意思），除了CS以外所有段寄存器的值都从0x0000编程了0x0008。CS保持原装是因为如果CS也变了，会造成混乱，所以只有CS要放到后面再处理。0x0008相当于“gdt+1”的段。





11. IN / OUT port
0x64 PORT_KEYCMD//键盘
0x64 PORT_KEYDAT//鼠标
0x03c7//读调色板号
0x03c8//写调色板号
0x03c9//调色板RGB数据
//将想要设定的调色板号码写入0x03c8,紧接着，按R,G,B的顺序写入0x03c9。
//如果想要读出当前调色板的状态，首先要将调色板的好吗写入0x03c7，再从0x03c9读取三次。

12. IN / OUT comand
0xd1 —— KEYCMD_WRITE_OUTPORT  //
0xdf —— KBC_OUTPORT_A20G_ENABLE

//这里发送的指令，是指令键盘控制电路的附属端口输出0xdf。这个附属端口连接着主板上的很多地方，通过这个端口发送不同的指令，就可以实现各种各样的控制功能。
//这次输出0xdf所要完成的功能，是让A20GATE信号线变成ON的状态。这条信号线的作用是什么呢？？？它能使内存1MB以上的部分变成可用状态。最初出现电脑的时候，CPU只有16位模式，所以内存最大只有1MB（ES*16+DS）。
//后来CPU变聪明了，可以使用很大的内存了。但为了兼容旧版的操作系统，在执行激活指令之前，电路被限制为智能使用1MB内存。和鼠标的情况类似，A20GATE信号线正是用来使用这个电路停止从而让所有的内存都可以使用的东西。

13.CPU家族
8086->80186->286->386->486->Pentium->PentiumPro->PentiumII->PentiumIII->Pentium4...
到286为止是16位，而386以后CPU是32位。

14.调色板颜色列表
#define COL8_000000     0   //黑
#define COL8_FF0000     1   //亮红
#define COL8_00FF00     2   //亮绿
#define COL8_FFFF00     3   //亮黄
#define COL8_0000FF     4   //亮蓝
#define COL8_FF00FF     5   //亮紫
#define COL8_00FFFF     6   //浅亮蓝
#define COL8_FFFFFF     7   //白
#define COL8_C6C6C6     8   //亮灰
#define COL8_840000     9   //暗红
#define COL8_008400     10  //暗绿
#define COL8_848400     11  //暗黄
#define COL8_000084     12  //暗青
#define COL8_840084     13  //暗紫
#define COL8_008484     14  //浅暗蓝
#define COL8_848484     15  //暗灰

15.CLI STI
CLI：将中断标志（interrupt flag）置为0的指令（clear interrupt flag）。
STI：是要将这个终端标志置为1的指令（set interrupt flag）。

16.EFLAGS
它是一个叫做EFLAGS的特殊寄存器。这是由名为FLAGS的16位寄存器扩展而来的32位寄存器。FLAGS是存储进位标志和中断标志等标志的寄存器。
进位标志可以通过JC货JNC等跳转指令来简单地判断到底是0还是1.但对于中断标志，没有类似的JI或JNI命令，所以只能读入EFLAGS，再检查第九位是0还是1.顺便说一下，进位标志是EFLAGS的第0位。

能够用来读写EFLAGS的，只有PUSHFD和POPFD指令。
PUSHFD： push flags double-word，意思是将标志位的值按双字节长压入栈。其实它所做的，就是“PUSH EFLAGS”。
POPFD： pop flags double-word, 意思是按双字节长将标志位从栈弹出。它所做的，就是“POP EFLAGS”









