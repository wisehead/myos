#1.hlt.hrb

##1.1 hlt.nas

```
[BITS 32]
        CLI
fin:
        HLT
        JMP     fin
```

将上面的代码保存为hlt.nas，然后用nask进行汇编，生成hlt.hrb。

##1.2 Makefile修改如下：

```
hlt.hrb : hlt.nas Makefile
    $(NASK) hlt.nas hlt.hrb hlt.lst
```

#2 怎样运行文件内容？
* 用file_loadfile将文件的内容读入到内存。
* 应用程序app不知道自己被读到哪个内存地址，这里暂且由ORIG 0来生成。因此为了APP能顺利运行，我们为它创建了一个段。
*  段创建好之后，接下来只要goto到该段中的程序，app就可以运行。goto到其它内存段，汇编里使用farjmp指令。

#3.示例代码

```cpp
else if (strcmp(cmdline, "hlt") == 0) {
    /*启动应用程序hlt.hrb */
    for (y = 0; y < 11; y++) {
        s[y] = ' ';
    }
    s[0] = 'H';
    s[1] = 'L';
    s[2] = 'T';
    s[8] = 'H';
    s[9] = 'R';
    s[10] = 'B';
    for (x = 0; x < 224; ) {
        if (finfo[x].name[0] == 0x00) {
            break;
        }
        if ((finfo[x].type & 0x18) == 0) {
            for (y = 0; y < 11; y++) {
                if (finfo[x].name[y] != s[y]) {
                    goto hlt_next_file;
                }
            }
            break; /*找到文件*/
        }
        hlt_next_file:
            x++;
    }
    if (x < 224 && finfo[x].name[0] != 0x00) {
        /*找到文件的情况*/
        p = (char *) memman_alloc_4k(memman, finfo[x].size);
        file_loadfile(finfo[x].clustno, finfo[x].size, p, fat, (char *) (ADR_DISKIMG + 0x003e00));
        set_segmdesc(gdt + 1003, finfo[x].size - 1, (int) p, AR_CODE32_ER);
        farjmp(0, 1003 * 8);
        memman_free_4k(memman, (int) p, finfo[x].size);
    } else {
        /*没有找到文件的情况*/
        putfonts8_asc_sht(sheet, 8, cursor_y, COL8_FFFFFF, COL8_000000, "File not found.", 15);
        cursor_y = cons_newline(cursor_y, sheet);
    }
    cursor_y = cons_newline(cursor_y, sheet);
}
```

#5.APP hard code
* 将开头的6个字节替换成 “EB 16 00 00 00 CB”
这6个字节相当于

```
[BITS 32]
	CALL 0x1b
	RETF
```

也就是调用0x1b这个地址的函数，从函数返回后，再执行far-RET。
这里的0x1b，就是.hrb的HariMain的地址。

* 为什么要搞这么复杂和奇怪呢？
因为：APP的运行原理，需要OS内核来调用APP，由于OS内核和APP不属于一个段，当时的临时方法是利用far-CALL来调用APP。
于是就需要这条指令来进行衔接。

* 为什么汇编不需要呢？只是C的APP需要衔接呢？？
如下代码：因为汇编APP不需要找HariMain类似的开始点，直接从汇编的第一句执行就OK了。
```
[INSTRSET "i486p"]
[BITS 32]
        MOV     ECX,msg
        MOV     EDX,1
putloop:
        MOV     AL,[CS:ECX]
        CMP     AL,0
        JE      fin
        INT     0x40
        ADD     ECX,1
        JMP     putloop
fin:
        MOV     EDX,4
        INT     0x40
msg:
        DB  "hello",0
```

如果按照标准的保护模式
这里就不需要了。？？？应该怎么办？？？想一想。

标准的保护模式利用GDT注册APP的代码段和数据段
然后在OS中通过RETF跳转到C APP的代码开始执行

利用RETF转到C APP的代码

#4 APP流程梳理
##4.1 APP本身启动流程
```
console_task
--cons_runcmd
----cmd_app
------file_search
------file_loadfile
------set_segmdesc(gdt + 1003, finfo->size - 1, (int) p, AR_CODE32_ER + 0x60);
------set_segmdesc(gdt + 1004, 64 * 1024 - 1, (int) q, AR_DATA32_RW + 0x60);
------start_app(0, 1003 * 8, 64 * 1024, 1004 * 8, &(task->tss.esp0));
--------//传入APP的代码段的地址
--------_start_app汇编程序
----------RETF//利用RETF转到C APP的代码
```
##4.2 调用API
```
HariMain
--api_putchar
----_api_putchar//a_nas.nas
------INT 0x40//开始调用API
--------asm_hrb_api//汇编，来到OS模式
----------_hrb_api
------------cons_putchar//C API
----------end_app//汇编
--api_end
```
##4.3 异常中断
```
_inthandler0d//汇编
--inthandler0d//C
--end_app//汇编
----RET         ; 返回cmd_app//OS task_console 返回到cmd_app
//返回cmd_app的结果是，加载的app代码退出。程序也退出。
```

```cpp
int *inthandler0d(int *esp)
{
    struct CONSOLE *cons = (struct CONSOLE *) *((int *) 0x0fec);
    struct TASK *task = task_now();
    cons_putstr0(cons, "\nINT 0D :\n General Protected Exception.\n");
    return &(task->tss.esp0);   /*强制结束程序*/
}
```

#5.没有关闭app的情况下，关闭console
* 1.用户点击命令行窗口，隐藏sheet，然后发送给console数据4.

```cpp
void HariMain() {
...
...
	task = sht->task;
	sheet_updown(sht, -1); /*暂且隐藏该图层*/
	keywin_off(key_win);
	key_win = shtctl->sheets[shtctl->top - 1];
	keywin_on(key_win);
	io_cli();
	fifo32_put(&task->fifo, 4);
	io_sti();	
}
```

2.console_task，接收到fifo数据，开始

```cpp
 62             if (i == 4) { /*点击命令行窗口的“×”按钮*/
 63                 cmd_exit(&cons, fat);
 64             }
```

3.console_task，运行cmd_exit，发送给task_a fifo /* 768〜1023 */，因为这个时候cons->sheet还在。

```cpp
void cmd_exit(struct CONSOLE *cons, int *fat)
{
    struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
    struct TASK *task = task_now();
    struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4);
    struct FIFO32 *fifo = (struct FIFO32 *) *((int *) 0x0fec);
    if (cons->sht != 0) {
        timer_cancel(cons->timer);
    }
    memman_free_4k(memman, (int) fat, 4 * 2880);
    io_cli();
    if (cons->sht != 0) {
        fifo32_put(fifo, cons->sht - shtctl->sheets0 + 768); /* 768〜1023 */
    } else {
        fifo32_put(fifo, task - taskctl->tasks0 + 1024); /*1024～2023*/
    }
    io_sti();
    for (;;) {
        task_sleep(task);
    }
}
```

4.task_main收到/* 768〜1023 */，会执行close_console

```cpp
void HariMain() {
...
...
304             } else if (768 <= i && i <= 1023) { /*命令行窗口关闭处理*/
305                 close_console(shtctl->sheets0 + (i - 768));
306             } else if (1024 <= i && i <= 2023) {
307                 close_constask(taskctl->tasks0 + (i - 1024));
308             } else if (2024 <= i && i <= 2279) { /*只关闭命令行窗口*/
309                 sht2 = shtctl->sheets0 + (i - 2024);
310                 memman_free_4k(memman, (int) sht2->buf, 256 * 165);
311                 sheet_free(sht2);
312             }
313         }
314     }
315 }
```

5.close_console

```cpp
void close_console(struct SHEET *sht)
{
    struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
    struct TASK *task = sht->task;
    memman_free_4k(memman, (int) sht->buf, 256 * 165);
    sheet_free(sht);
    close_constask(task);
    return;
}

void close_constask(struct TASK *task)
{
    struct MEMMAN *memman = (struct MEMMAN *) MEMMAN_ADDR;
    task_sleep(task);
    memman_free_4k(memman, task->cons_stack, 64 * 1024);
    memman_free_4k(memman, (int) task->fifo.buf, 128 * 4);
    task->flags = 0; /*用来替代task_free(task); */
    return;
}
close_console
--close_constask
```