#1.INT——中断
* (1)INT 0x10——调用显卡BIOS
	* AH:0x00 :设置显卡模式。AL指定模式。
		* AL=0x13：VGA显卡，320*200*8位彩色
		* AL=0x03：16色字符模式，80*25。
		* AL=0x12：VGA图形模式，640*480*4位彩色模式，独特的4面存储模式。
		* AL=0x6a：扩展VGA模式，800*600*4位彩色模式，独特的4面存储模式。
	* AH:0x0e ：显示一个文字。BX指定文字颜色。

* (2)INT 0x13——磁盘读写，扇区校验(verify)，以及寻道(seek)。具体参数查阅百度
AH:0x00 :系统复位
AH:0x02 :读盘
AH:0x03 :写盘
AH:0x04 :校验
AH:0x0c :寻道

* (3)INT 0x16

		; 用BIOS取得键盘上各种LED指示灯的状态。
		MOV AH, 0x02
		INT 0x16
		MOV [LEDS], AL
	
* INT 0x20：定时器
* (4)INT 0x21
* (5)INT 0x27
* (6)INT 0x2c

#2.BIOS中断和DOS中断的区别

bios是主板预装好的input、output系统，而dos是需要安装才能使用操作系统。用int条用中断以后可以通过不同的系统达到不同的目的和效果。其中int 1 -20 是bios中断，int21 专门用于dos中断。
只有16位汇编才能访问BIOS，32位汇编不能访问。

电脑里有个名为BIOS的程序，出厂时就组装在电脑主板上的ROM单元里。电脑厂家在BIOS里预先写入了操作系统开发人员经常会用到的一些程序。

最近的BIOS功能非常多，设置包括了电脑的设定画面，不过它的本质正如其名，就是操作系统开发人员准备的各种函数的集合。而INT就是用来调用这些函数的指令。
INT后面是个数字，不同的数字可以调用不同的函数。这次我们调用的是0x10(即16)号函数，它的功能是控制显卡。

#3.CLI STI
CLI：将中断标志（interrupt flag）置为0的指令（clear interrupt flag）。
STI：是要将这个终端标志置为1的指令（set interrupt flag）。

#4.IDT
IDT是“interrupt descriptor table”的缩写，直译过来就是“中断记录表”。当CPU遇到外部状况变化，或者是内部偶然发生某些错误时，会临时切花过去处理这种突发事件。这就是中断功能。

IDT记录了0~255的中断号码和调用函数的对应关系。

中断本质上将是为了解决CPU和外部慢设备之间的问题。避免了CPU轮询的低效。

各个设备有变化时，就产生中断，中断发生后，CPU暂时停止正在处理的任务，并做好接下来继续处理的准备，转而执行中断程序。中断程序执行完后，再调用事先设定好的函数，返回处理中的任务。
正是得益于中断机制，CPU可以不用一直查询键盘、鼠标、网卡等设备的状态，将精力集中在处理任务上。

要使用鼠标，就不许使用中断。所以，我们必须设定IDT，IDT记录了0~255的中断号码于调用函数的对应关系，比如说发生了123号中断，就调用handler123()函数，其设定方法于GDT很类似。

#5.PIC
	PIC:programmable interrupt controller.) 可编程中断控制器。
	IMR: interrupt mask register, 中断屏蔽寄存器（8位）
	ICW: initial control word. 初始化控制数据（8位）

* CPU只能处理一个中断，不够用，所以IBM在主板上增加了辅助芯片。现在他们已经被集成到一个芯片组里了。

* PIC是将8个中断信号集合成一个中断信号的装置。PIC监视着输入管教的8个中断信号。只要有一个中断信号进来，就将唯一的输出管教信号变成ON，并通知给CPU。IBM想要通过增加PIC来处理更多的中断信号，因为电脑上会有8个以上的外部设备，所以就把中断信号设计成15个，并为此增设了两个PIC。
 
* 与CPU直接相连的PIC是主PIC，与主PIC相连的PIC是从PIC。主PIC负责处理0号到7号的中断信号，从PIC负责处理从8号到15号的中断信号。
 另外，从PIC通过2号IRQ与主PIC相连。

```cpp
void init_pic(void)
/*PIC初始化 */
{
    io_out8(PIC0_IMR,  0xff  ); /* 禁止所有中断 */
    io_out8(PIC1_IMR,  0xff  ); /* 禁止所有中断 */

    io_out8(PIC0_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC0_ICW2, 0x20  ); /* IRQ0-7由INT20-27接收 */
    io_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2相连 */
    io_out8(PIC0_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC1_ICW1, 0x11  ); /* 边缘触发模式（edge trigger mode） */
    io_out8(PIC1_ICW2, 0x28  ); /* IRQ8-15由INT28-2f接收 */
    io_out8(PIC1_ICW3, 2     ); /* PIC1由IRQ2连接 */
    io_out8(PIC1_ICW4, 0x01  ); /* 无缓冲区模式 */

    io_out8(PIC0_IMR,  0xfb  ); /* 11111011 PIC1以外全部禁止 */
    io_out8(PIC1_IMR,  0xff  ); /* 11111111 禁止所有中断 */

    return;
}
```

* IMR: interrupt mask register, 中断屏蔽寄存器。
8位分别对应8路IRQ信号。如果某一位的值是1，则该位所对应的IRQ信号被屏蔽，PIC就忽略该信号。

* ICW: initial control word. 初始化控制数据
ICW有4个，分别编号为1~4，共有4个字节的数据。

* INT0x20~0x2f接收中断信号IRQ0~15，INT 0x00~0x1f不能用。当应用程序想要干坏事的时候，CPU内部会自动产生INT0x00~0x1f，如果IRQ与这些号码重复了，CPU就分不清它到底是IRQ，还是CPU的系统保护通知。

* 鼠标是IRQ12，键盘是IRQ1
所以用int 0x2c 和int 0x21的中断处理程序来处理二者的中断。
